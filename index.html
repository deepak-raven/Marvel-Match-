<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candy Crush with Custom Effects</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
        }
        .font-fredoka {
            font-family: 'Fredoka One', cursive;
        }
        .candy-cell {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            padding: 8%;
            box-sizing: border-box;
        }
        .candy-cell img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.3s ease, opacity 0.3s ease;
            -webkit-user-drag: none;
            user-select: none;
            /* Added this to make sure the image is always on top of the glow */
            position: relative;
            z-index: 2;
        }
        
        /* --- POWERED CANDY EFFECTS (GLOW UPDATED) --- */
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 7px 2px rgba(255, 255, 100, 0.7); }
            50% { box-shadow: 0 0 20px 8px rgba(255, 255, 100, 1); }
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8%); }
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Applying the animations */
        .effect-glow {
            border-radius: 9999px; /* Makes the glow circular */
            animation: glow 1.8s ease-in-out infinite;
            z-index: 1;
        }
        .effect-float img {
            animation: float 2.2s ease-in-out infinite;
        }
        .effect-spin img {
            animation: spin 5s linear infinite;
        }
        /* --- END EFFECTS --- */

        .candy-cell.matched img {
            transform: scale(0);
            opacity: 0;
        }
    </style>
</head>
<body class="bg-pink-300 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto">
        <h1 class="text-5xl md:text-6xl text-white font-fredoka text-center mb-4" style="text-shadow: 3px 3px 0px rgba(0,0,0,0.2);">Candy Crush</h1>

        <div class="flex justify-around bg-white/50 rounded-lg p-3 mb-4 text-center shadow-lg">
            <div>
                <span class="font-fredoka text-pink-600 text-lg">Score</span>
                <p id="score" class="text-3xl font-bold text-white">0</p>
            </div>
            <div>
                <span class="font-fredoka text-pink-600 text-lg">Moves</span>
                <p id="moves" class="text-3xl font-bold text-white">30</p>
            </div>
        </div>

        <div id="game-board" class="grid grid-cols-8 gap-1 bg-pink-200/60 p-2 rounded-lg shadow-inner aspect-square"></div>
    </div>

    <div id="modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
            <h2 id="modal-title" class="text-4xl font-fredoka text-pink-500 mb-4">Game Over!</h2>
            <p class="text-gray-700 mb-6 text-lg">Your final score is <span id="final-score" class="font-bold">0</span>.</p>
            <button id="restart-button" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-8 rounded-full text-xl font-fredoka transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const movesElement = document.getElementById('moves');
            const modal = document.getElementById('modal');
            
            const boardSize = 8;
            const initialMoves = 30;

            // --- YOUR CANDY IMAGES & EFFECTS GO HERE ---
            // This part works exactly the same as before.
            const candyMappings = [
                {
                    normal:  'images/Thor/1.jpg',
                    row:     'images/Thor/2.png',
                    col:     'images/Thor/2.png',
                    wrapped: 'images/Thor/3.png',
                    effects: ['glow']
                },
                {
                    normal:  'images/CaptainAmeica/1.png',
                    row:     'images/CaptainAmeica/2.png',
                    col:     'images/CaptainAmeica/2.png',
                    wrapped: 'images/CaptainAmeica/3.png',
                    effects: ['float']
                },
                {
                    normal:  'images/Groot/1.png',
                    row:     'images/Groot/2.png',
                    col:     'images/Groot/2.png',
                    wrapped: 'images/Groot/3.png',
                    effects: ['spin']
                },
                {
                    normal:  'images/SpiderMan/1.png',
                    row:     'images/SpiderMan/2.png',
                    col:     'images/SpiderMan/2.png,
                    wrapped: 'images/SpiderMan/3.png',
                    effects: ['glow', 'float']
                },
                {
                    normal:  'images/Hulk/1.png',
                    row:     'images/Hulk/2.png',
                    col:     'images/Groot/2.png',
                    wrapped: 'images/Groot/3.png',
                    effects: ['glow', 'spin']
                },
                {
                    normal:  'images/BlackPanther/1.pnge',
                    row:     'images/BlackPanther/1.pngw',
                    col:     'images/BlackPanther/1.pngl',
                    wrapped: 'images/BlackPanther/1.png',
                    effects: []
                }
            ];
            const colorBombUrl = 'images/agamato.png';
            // ------------------------------------

            const allNormalCandies = candyMappings.map(c => c.normal);
            let board = [];
            let score = 0;
            let moves = initialMoves;
            let isProcessing = false;
            let draggedCandy, replacedCandy = null;

            function createCandyObject(url, type = 'normal') { return { url, type }; }

            function initGame() {
                score = 0;
                moves = initialMoves;
                isProcessing = false;
                updateDisplay();
                createBoard();
                modal.classList.add('hidden');
            }

            function createBoard() {
                board = [];
                for (let r = 0; r < boardSize; r++) {
                    const rowArray = [];
                    for (let c = 0; c < boardSize; c++) {
                        let randomUrl;
                        do {
                            randomUrl = allNormalCandies[Math.floor(Math.random() * allNormalCandies.length)];
                        } while (
                            (c >= 2 && getNormalUrl(rowArray[c - 1].url) === randomUrl && getNormalUrl(rowArray[c - 2].url) === randomUrl) ||
                            (r >= 2 && getNormalUrl(board[r - 1][c].url) === randomUrl && getNormalUrl(board[r - 2][c].url) === randomUrl)
                        );
                        rowArray.push(createCandyObject(randomUrl));
                    }
                    board.push(rowArray);
                }
                renderBoard();
            }
            
            function getNormalUrl(url) {
                if (url === colorBombUrl) return null;
                for (const mapping of candyMappings) {
                    if (Object.values(mapping).includes(url)) return mapping.normal;
                }
                return url;
            }

            function renderBoard() {
                boardElement.innerHTML = '';
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        const candy = board[r][c];
                        const cell = document.createElement('div');
                        cell.classList.add('candy-cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        if (candy) {
                            const candyImage = document.createElement('img');
                            candyImage.src = candy.url;
                            candyImage.setAttribute('draggable', false);
                            cell.appendChild(candyImage);

                            if (candy.type !== 'normal') {
                                const normalUrl = getNormalUrl(candy.url);
                                const mapping = candyMappings.find(m => m.normal === normalUrl);
                                if (mapping && mapping.effects) {
                                    mapping.effects.forEach(effect => cell.classList.add(`effect-${effect}`));
                                }
                                if (candy.type === 'bomb') cell.classList.add('effect-glow');
                            }
                        }

                        cell.setAttribute('draggable', true);
                        cell.addEventListener('dragstart', dragStart);
                        cell.addEventListener('dragover', e => e.preventDefault());
                        cell.addEventListener('drop', dragDrop);
                        cell.addEventListener('dragend', dragEnd);
                        cell.addEventListener('touchstart', dragStart, { passive: false });
                        cell.addEventListener('touchmove', touchMove, { passive: false });
                        cell.addEventListener('touchend', dragEnd);
                        boardElement.appendChild(cell);
                    }
                }
            }

            function dragStart(e) { if (!isProcessing) draggedCandy = this; }
            function dragDrop(e) { if (!isProcessing) replacedCandy = this; }
            function touchMove(e) {
                if (!draggedCandy) return;
                e.preventDefault();
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.closest('.candy-cell')) replacedCandy = target.closest('.candy-cell');
            }

            async function dragEnd() {
                if (isProcessing || !draggedCandy || !replacedCandy || draggedCandy === replacedCandy) {
                    draggedCandy = null; replacedCandy = null; return;
                }
                isProcessing = true;
                const dRow = parseInt(draggedCandy.dataset.row), dCol = parseInt(draggedCandy.dataset.col);
                const rRow = parseInt(replacedCandy.dataset.row), rCol = parseInt(replacedCandy.dataset.col);

                if (Math.abs(dRow - rRow) + Math.abs(dCol - rCol) !== 1) {
                    draggedCandy = null; replacedCandy = null; isProcessing = false; return;
                }
                
                moves--;
                updateDisplay();
                await swapAndCheck(dRow, dCol, rRow, rCol);

                if (moves <= 0) setTimeout(gameOver, 500);
                draggedCandy = null; replacedCandy = null; isProcessing = false;
            }

            async function swapAndCheck(r1, c1, r2, c2) {
                await swapCandies(r1, c1, r2, c2);
                const candy1 = board[r1][c1], candy2 = board[r2][c2];

                if (candy1.type === 'bomb' || candy2.type === 'bomb') {
                    let bombPos = candy1.type === 'bomb' ? [r1,c1] : [r2,c2];
                    let targetCandy = candy1.type === 'bomb' ? candy2 : candy1;
                    let targetUrl = getNormalUrl(targetCandy.url);
                    const toClear = new Set([`${bombPos[0]}-${bombPos[1]}`]);
                    if (targetUrl) {
                        for(let r=0; r<boardSize; r++) for(let c=0; c<boardSize; c++) {
                            if (board[r][c] && getNormalUrl(board[r][c].url) === targetUrl) toClear.add(`${r}-${c}`);
                        }
                    }
                    await processMatches(Array.from(toClear).map(coord => coord.split('-').map(Number)));
                } else {
                    const matchInfo = findMatches();
                    if (matchInfo.allMatchedCoords.size > 0) {
                        await processMatches(Array.from(matchInfo.allMatchedCoords).map(c => c.split('-').map(Number)), matchInfo.specialMatches);
                    } else {
                        await new Promise(r => setTimeout(r, 200));
                        await swapCandies(r1, c1, r2, c2);
                    }
                }
            }
            
            async function swapCandies(r1, c1, r2, c2) {
                [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
                renderBoard();
                return new Promise(resolve => setTimeout(resolve, 200));
            }
            
            function findMatches() {
                const horizontalMatches = [], verticalMatches = [];
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize - 2; c++) {
                        const candy1 = board[r][c];
                        if (!candy1) continue;
                        const normalUrl = getNormalUrl(candy1.url);
                        if (!normalUrl) continue;
                        let line = [{r,c}];
                        for (let i = 1; c + i < boardSize; i++) {
                           const nextCandy = board[r][c+i];
                           if(nextCandy && getNormalUrl(nextCandy.url) === normalUrl) line.push({r, c:c+i});
                           else break;
                        }
                        if(line.length >= 3) {
                            horizontalMatches.push(line);
                            c += line.length - 1;
                        }
                    }
                }
                 for (let c = 0; c < boardSize; c++) {
                    for (let r = 0; r < boardSize - 2; r++) {
                        const candy1 = board[r][c];
                        if (!candy1) continue;
                        const normalUrl = getNormalUrl(candy1.url);
                        if (!normalUrl) continue;
                        let line = [{r,c}];
                        for (let i = 1; r + i < boardSize; i++) {
                           const nextCandy = board[r+i][c];
                           if(nextCandy && getNormalUrl(nextCandy.url) === normalUrl) line.push({r: r+i, c});
                           else break;
                        }
                        if(line.length >= 3) {
                            verticalMatches.push(line);
                            r += line.length - 1;
                        }
                    }
                }

                const allMatchedCoords = new Set();
                const specialMatches = [];
                const processedLines = new Set();
                for (const hLine of horizontalMatches) {
                    for (const vLine of verticalMatches) {
                        const hCoords = new Set(hLine.map(p => `${p.r}-${p.c}`));
                        const vCoords = new Set(vLine.map(p => `${p.r}-${p.c}`));
                        const intersection = [...hCoords].filter(coord => vCoords.has(coord));
                        if (intersection.length > 0) {
                            processedLines.add(hLine).add(vLine);
                            [...hLine, ...vLine].forEach(p => allMatchedCoords.add(`${p.r}-${p.c}`));
                            specialMatches.push({
                                type: 'wrapped',
                                url: getNormalUrl(board[hLine[0].r][hLine[0].c].url),
                                placement: intersection[0].split('-').map(Number)
                            });
                        }
                    }
                }
                [...horizontalMatches, ...verticalMatches].forEach(line => {
                    if (processedLines.has(line)) return;
                    line.forEach(p => allMatchedCoords.add(`${p.r}-${p.c}`));
                    if (line.length >= 4) {
                        specialMatches.push({
                            type: line.length >= 5 ? 'bomb' : (line[0].r === line[1].r ? 'col' : 'row'),
                            url: getNormalUrl(board[line[0].r][line[0].c].url),
                            placement: [line[0].r, line[0].c]
                        });
                    }
                });
                return { allMatchedCoords, specialMatches };
            }

            async function processMatches(coords, specialMatches = []) {
                let toClear = new Set(coords.map(([r, c]) => `${r}-${c}`));
                for (const [r, c] of coords) {
                    const candy = board[r][c];
                    if (candy && candy.type !== 'normal') activateSpecial(r, c, candy.type, toClear);
                }
                score += toClear.size * 10;
                updateDisplay();
                for (const coord of toClear) {
                    const [r, c] = coord.split('-').map(Number);
                    const cell = boardElement.querySelector(`[data-row='${r}'][data-col='${c}']`);
                    if (cell) cell.classList.add('matched');
                }
                await new Promise(r => setTimeout(r, 300));

                for (const coord of toClear) {
                    const [r, c] = coord.split('-').map(Number);
                    board[r][c] = null;
                }
                
                if (specialMatches.length > 0) {
                    for (const match of specialMatches) {
                         const [r,c] = match.placement;
                         if (board[r][c] !== null) continue; 
                         let newUrl, mapping;
                         switch(match.type) {
                             case 'bomb': newUrl = colorBombUrl; break;
                             case 'row': case 'col': case 'wrapped':
                                 mapping = candyMappings.find(m => m.normal === match.url);
                                 if (mapping) newUrl = mapping[match.type];
                                 break;
                         }
                         if(newUrl) board[r][c] = createCandyObject(newUrl, match.type);
                    }
                }
                
                await applyGravityAndRefill();
                const newMatchInfo = findMatches();
                if (newMatchInfo.allMatchedCoords.size > 0) {
                    await processMatches(Array.from(newMatchInfo.allMatchedCoords).map(c => c.split('-').map(Number)), newMatchInfo.specialMatches);
                }
            }

            function activateSpecial(r, c, type, toClear) {
                if (type === 'row') for (let i = 0; i < boardSize; i++) if(board[r][i]) toClear.add(`${r}-${i}`);
                if (type === 'col') for (let i = 0; i < boardSize; i++) if(board[i][c]) toClear.add(`${i}-${c}`);
                if (type === 'wrapped') {
                    for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                        const nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && board[nr][nc]) {
                            toClear.add(`${nr}-${nc}`);
                        }
                    }
                }
            }

            async function applyGravityAndRefill() {
                for (let c = 0; c < boardSize; c++) {
                    let emptyRow = boardSize - 1;
                    for (let r = boardSize - 1; r >= 0; r--) {
                        if (board[r][c] !== null) {
                            if (r !== emptyRow) {
                                board[emptyRow][c] = board[r][c];
                                board[r][c] = null;
                            }
                            emptyRow--;
                        }
                    }
                }
                for (let c = 0; c < boardSize; c++) {
                    for (let r = boardSize - 1; r >= 0; r--) {
                        if (board[r][c] === null) {
                            board[r][c] = createCandyObject(allNormalCandies[Math.floor(Math.random() * allNormalCandies.length)]);
                        }
                    }
                }
                renderBoard(); 
                return new Promise(r => setTimeout(r, 300));
            }

            function gameOver() {
                isProcessing = true;
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.getElementById('final-score').textContent = score;
            }

            function updateDisplay() {
                scoreElement.textContent = score;
                movesElement.textContent = moves;
            }

            document.getElementById('restart-button').addEventListener('click', initGame);
            initGame();
        });
    </script>
</body>
</html>
